{"version":3,"file":"static/js/872.804927f4.chunk.js","mappings":"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","sources":["Checkers/game/movesStorage/movesStorage.tsx","Checkers/game/stone/KingIcon.tsx","Checkers/game/stone/Stone.tsx","Checkers/game/Stones.tsx","Checkers/game/Board.tsx","Checkers/game/Game.tsx"],"sourcesContent":["import { createContext, FC, ReactNode, useContext, useState } from 'react';\r\nimport { MoveTrees, Position } from './movesUtils.ts';\r\nimport { useGameStorageContext } from '../gameStorage/gameStorage.tsx';\r\nimport { calculateCurrentPlayerMoveTrees } from './movesUtils.ts';\r\n\r\nexport const useMovesStorage = () => {\r\n    const {\r\n        currentPlayer,\r\n        boardGrid\r\n    } = useGameStorageContext();\r\n\r\n    const [selectedPosition, setSelectedPosition] = useState<Position | null>(null);\r\n    const [currentPlayerMoveTrees, setCurrentPlayerMoveTrees] = useState<MoveTrees>(calculateCurrentPlayerMoveTrees(boardGrid, currentPlayer));\r\n    \r\n    return {\r\n        selectedPosition,\r\n        setSelectedPosition,\r\n        currentPlayerMoveTrees,\r\n        setCurrentPlayerMoveTrees\r\n    };\r\n}\r\n\r\n\r\nconst MovesStorageContext = createContext<ReturnType<typeof useMovesStorage> | null>(null);\r\n\r\nexport const MovesStorageProvider: FC<{ children: ReactNode }> = ({ children }) => {\r\n    const value = useMovesStorage();\r\n    return (\r\n        <MovesStorageContext.Provider \r\n            value={value}\r\n        >\r\n            {children}\r\n        </MovesStorageContext.Provider>\r\n    );\r\n};\r\n\r\nexport function useMovesStorageProvider() {\r\n    const context = useContext(MovesStorageContext);\r\n    if (!context) {\r\n        throw new Error('usMovesStorageContext must be used within a MovesStorageProvider');\r\n    }\r\n    return context;\r\n}","import { FC } from 'react';\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { faCrown } from '@fortawesome/free-solid-svg-icons';\r\nimport { useGameStorageContext } from '../gameStorage/gameStorage.tsx';\r\n\r\n/**\r\n * Represents the dimensions of the KingIcon.\r\n * - `width`: The width of the icon in pixels.\r\n * - `height`: The height of the icon in pixels.\r\n * - `left`: The left position of the icon in pixels.\r\n * - `top`: The top position of the icon in pixels.\r\n */\r\ninterface KingIconDimensions {\r\n    width: number;\r\n    height: number;\r\n    left: number;\r\n    top: number;\r\n}\r\n\r\n/**\r\n * Represents the cache for the KingIcon dimensions.\r\n * - The key is the stone diameter, and the value is the dimensions of the icon.\r\n */\r\ninterface KingIconDimensionsCache {\r\n    [stoneDiameter: number]: KingIconDimensions;\r\n}\r\n\r\n// The cache for the KingIcon dimensions.\r\nconst _KING_ICON_DIMENSIONS_CACHE: KingIconDimensionsCache = {};\r\n\r\n/**\r\n * Represents the cache for the KingIcon component.\r\n * - The key is the stone diameter, and the value is the cached KingIcon FontAwesomeIcon component.\r\n */\r\ninterface KingIconCache {\r\n    [stoneDiameter: number]: React.ReactNode;\r\n}\r\n\r\n// The cache for the KingIcon component.\r\nconst _KING_ICON_CACHE: KingIconCache = {};\r\n\r\nconst KingIcon: FC = () => {\r\n    const { \r\n        stoneDiameter \r\n    } = useGameStorageContext();\r\n\r\n    /**\r\n     * Calculates the dimensions of the KingIcon based on the stone diameter.\r\n     * @returns {KingIconDimensions} - An object containing the dimensions of the king icon.\r\n     */\r\n    const calculateDimensions = (): KingIconDimensions => {\r\n        // If the dimensions are already cached for the current stone diameter,\r\n        // return the cached dimensions.\r\n        const cachedDimensions = _KING_ICON_DIMENSIONS_CACHE[stoneDiameter];\r\n        if (cachedDimensions) {\r\n            return cachedDimensions;\r\n        }\r\n        \r\n        const iconSize = Math.round(stoneDiameter * 0.5 * 10) / 10;\r\n        const iconCenterOffset = Math.round((stoneDiameter - iconSize) / 2 * 10) / 10;\r\n        const iconDimensions: KingIconDimensions = {\r\n            width: iconSize,\r\n            height: iconSize,\r\n            left: iconCenterOffset,\r\n            top: iconCenterOffset\r\n        }\r\n\r\n        // Cache the dimensions for the current stone diameter.\r\n        _KING_ICON_DIMENSIONS_CACHE[stoneDiameter] = iconDimensions;\r\n\r\n        return iconDimensions;\r\n    }\r\n    \r\n    /**\r\n     * Returns the KingIcon component, either from the cache or by creating a new one.\r\n     * @param {() => React.ReactNode} createKingIcon - A function that creates the KingIcon component.\r\n     * @returns {React.ReactNode} - The KingIcon component.\r\n     */\r\n    const getKingIcon = (createKingIcon: () => React.ReactNode): React.ReactNode => {\r\n        // If the KingIcon is already cached for the current stone diameter,\r\n        // return the cached KingIcon component.\r\n        const cachedKingIcon = _KING_ICON_CACHE[stoneDiameter];\r\n        if (cachedKingIcon) {\r\n            return cachedKingIcon;\r\n        }\r\n\r\n        // Otherwise, create a new KingIcon component and cache it.\r\n        const kingIcon = createKingIcon();\r\n        _KING_ICON_CACHE[stoneDiameter] = kingIcon;\r\n        \r\n        return kingIcon\r\n    }\r\n\r\n    return getKingIcon(\r\n        () => {\r\n            const { width, height, left, top } = calculateDimensions();\r\n            return (\r\n                <FontAwesomeIcon\r\n                    icon={faCrown}\r\n                    className='position-absolute'\r\n                    style={{\r\n                        width: `${width}px`,\r\n                        height: `${height}px`,\r\n                        left: `${left}px`,\r\n                        top: `${top}px`,\r\n                        color: 'gold'\r\n                    }}\r\n                />\r\n            );\r\n        }\r\n    );\r\n}\r\n\r\n\r\n\r\nexport default KingIcon;","import { FC, MouseEvent, useMemo, DragEvent } from 'react';\r\nimport { Position } from '../movesStorage/movesUtils.ts';\r\nimport { Player } from '../../settings/settingsStorage/settingsStorageUtils.ts';\r\nimport { useGameStorageContext } from '../gameStorage/gameStorage.tsx';\r\nimport { useMovesStorageProvider } from '../movesStorage/movesStorage.tsx';\r\nimport KingIcon from './KingIcon.tsx';\r\nimport './stoneStyles.scss';\r\n\r\n/**\r\n * Represents the properties of a stone in the game.\r\n * - `position`: The position of the stone on the board.\r\n * - `player`: The player who owns the stone.\r\n * - `isKing`: Indicates whether the stone is a king.\r\n */\r\ninterface StoneProps {\r\n    position: Position;\r\n    player: Player;\r\n    isKing: boolean;\r\n}\r\n\r\n/**\r\n * Represents the dimensions of a stone on the board.\r\n * - `diameter`: The diameter of the stone in pixels.\r\n * - `left`: The left position of the stone in pixels.\r\n * - `top`: The top position of the stone in pixels.\r\n */\r\ninterface StoneDimensions {\r\n    diameter: number;\r\n    left: number;\r\n    top: number;\r\n}\r\n\r\nconst Stone: FC<StoneProps> = (props) => {\r\n    const {\r\n        position,\r\n        player,\r\n        isKing\r\n    } = props;\r\n\r\n    const {\r\n        tileSize,\r\n        stoneDiameter,\r\n        currentPlayer\r\n    } = useGameStorageContext();\r\n\r\n    const {\r\n        selectedPosition,\r\n        setSelectedPosition,\r\n        currentPlayerMoveTrees\r\n    } = useMovesStorageProvider();\r\n\r\n    /**\r\n     * Returns the dimensions of the stone based on its position, size of the tiles on the board, and the stone diameter.\r\n     * @returns {StoneDimensions} - The dimensions of the stone.\r\n     */\r\n    const stoneDimensions = useMemo<StoneDimensions>(() => {\r\n        const [row, col] = position;\r\n        const centeringOffset = Math.round((tileSize - stoneDiameter) / 2 * 10) / 10;\r\n        const left = Math.round((col * tileSize + centeringOffset) * 10) / 10;\r\n        const top = Math.round((row * tileSize + centeringOffset) * 10) / 10;\r\n        const stoneDimensions: StoneDimensions = {\r\n            diameter: stoneDiameter,\r\n            left,\r\n            top\r\n        };\r\n        \r\n        return stoneDimensions;\r\n    }, [position, tileSize, stoneDiameter]);\r\n\r\n    /**\r\n     * Returns whether the stone can be moved or not.\r\n     * - A stone can be moved if:\r\n     *   * It belongs to the current player.\r\n     *   * There are possible moves from its position.\r\n     * @returns {boolean} - True if the stone can be moved, false otherwise.\r\n     */\r\n    const canMove = useMemo(() => {\r\n        if (player !== currentPlayer) {\r\n            return false;\r\n        }\r\n\r\n        const positionString = position.toString();\r\n        if (!currentPlayerMoveTrees[positionString]) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }, [currentPlayer, player, currentPlayerMoveTrees, position]);\r\n\r\n    /**\r\n     * Returns whether the stone is selected or not.\r\n     * @returns {boolean} - True if the stone is selected, false otherwise.\r\n     */\r\n    const isSelected = useMemo(() => {\r\n        if (!selectedPosition) {\r\n            return false;\r\n        }\r\n\r\n        const isCurrentStoneSelected  = (\r\n            selectedPosition[0] === position[0] &&\r\n            selectedPosition[1] === position[1]\r\n        );\r\n\r\n        return isCurrentStoneSelected;\r\n    }, [selectedPosition, position]);\r\n\r\n    /**\r\n     * Handles the mouse down event on the stone.\r\n     * If the stone can be moved and is not already selected, it sets the stone as the selected position.\r\n     * @param {MouseEvent<HTMLDivElement>} ev - The mouse event.\r\n     * @returns {void}\r\n     */\r\n    const onmousedownHandler = (ev: MouseEvent<HTMLDivElement>): void => {\r\n        if (!canMove) {\r\n            ev.preventDefault();\r\n            return;\r\n        }\r\n\r\n        if (!isSelected) {\r\n            setSelectedPosition(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles the drag over event on the stone.\r\n     * If the stone that is being dragged is being dragged over itself, it prevents the default behavior.\r\n     * (Which is this use case removes the cursor \"not-allowed\" icon when dragging over itself).\r\n     * @param {DragEvent<HTMLDivElement>} ev - The drag event.\r\n     * @returns {void}\r\n     */\r\n    const ondragoverHandler = (ev: DragEvent<HTMLDivElement>): void => {\r\n        if (isSelected) {\r\n            ev.preventDefault();\r\n        }\r\n    }\r\n\r\n    const { diameter, left, top } = stoneDimensions;\r\n    return (\r\n        <div\r\n            className={\r\n                'stone' +\r\n                (isSelected ? ' selected-stone' : '')\r\n            }\r\n            style={{\r\n                width: `${diameter}px`,\r\n                height: `${diameter}px`,\r\n                left: `${left}px`,\r\n                top: `${top}px`,\r\n                backgroundColor: `var(--player-${player}-stone-color)`\r\n            }}\r\n            draggable={canMove}\r\n            onMouseDown={onmousedownHandler}\r\n            onDragOver={ondragoverHandler}\r\n        >\r\n            {isKing &&\r\n                <KingIcon />\r\n            }\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Stone;","import { FC, useEffect } from 'react';\r\nimport { useGameStorageContext } from './gameStorage/gameStorage.tsx';\r\nimport Stone from './stone/Stone.tsx';\r\n\r\nconst Stones: FC = () => {\r\n    const {\r\n        boardGrid,\r\n        setStoneDiameter,\r\n        tileSize\r\n    } = useGameStorageContext();\r\n    \r\n    // We set the `stoneDiameter` storage state based on the `tileSize` storage state.\r\n    // We do this when the component mounts and when the `tileSize` changes.\r\n    // This is used within the `Stone` component.\r\n    // We set the `stoneDiameter` in this component since if we do it within the `Stone` component,\r\n    // it would be set multiple times (once for each stone).\r\n    useEffect(() => {\r\n        const newStoneDiameter = tileSize * .75;\r\n        setStoneDiameter(newStoneDiameter);\r\n    }, [tileSize, setStoneDiameter]);\r\n\r\n    return (\r\n        <>\r\n            {boardGrid.flatMap(row => \r\n                row.map(stone => {\r\n                    if (!stone) {\r\n                        return null;\r\n                    }\r\n\r\n                    const {\r\n                        position,\r\n                        player, \r\n                        isKing, \r\n                        id \r\n                    } = stone;\r\n\r\n                    return (\r\n                        <Stone\r\n                            position={position}\r\n                            player={player}\r\n                            isKing={isKing}\r\n                            key={id}\r\n                        />\r\n                    );\r\n                })\r\n            )}\r\n        </>\r\n    );\r\n}\r\n\r\nexport default Stones;","import { FC, useCallback, useEffect } from 'react';\r\nimport { useGameStorageContext } from './gameStorage/gameStorage.tsx';\r\nimport { useSettingsStorageContext } from '../settings/settingsStorage/settingsStorage.tsx';\r\nimport Stones from './Stones.tsx';\r\n\r\n/**\r\n * Interface for the board dimensions.\r\n * - `boardSize`: The size of the board in pixels.\r\n * - `tileSize`: The size of each tile in pixels.\r\n */\r\ninterface BoardDimensions {\r\n    boardSize: number;\r\n    tileSize: number;\r\n}\r\n\r\n/**\r\n * Percentage of the board's container that the board can cover.\r\n */\r\nconst _BOARD_CONTAINER_COVERAGE_PERCENTAGE = .8;\r\n\r\nconst Board: FC = () => {\r\n    const {\r\n        tileSize,\r\n        setTileSize,\r\n        boardSize,\r\n        setBoardSize\r\n    } = useGameStorageContext();\r\n\r\n    const {\r\n        boardRowsAmount\r\n    } = useSettingsStorageContext();\r\n\r\n    /**\r\n     * Calculates the sizes of the board and tiles based on the window size.\r\n     * - It ensures that the board is square and fits within the available space.\r\n     * @returns {BoardDimensions} - An object containing the board size and tile size.\r\n     */\r\n    const calculateBoardSizes = useCallback((): BoardDimensions => {\r\n        // Calculate the maximum available space based on window size and the allowed coverage percentage.\r\n        const availableHeight = window.innerHeight * _BOARD_CONTAINER_COVERAGE_PERCENTAGE;\r\n        const availableWidth = window.innerWidth * _BOARD_CONTAINER_COVERAGE_PERCENTAGE;\r\n        \r\n        // Calculate the smallest dimension between the available height and width.\r\n        const availableSize = Math.min(availableHeight, availableWidth);\r\n        \r\n        // Calculate the size of each tile in pixels\r\n        const newTileSize = Math.floor(availableSize / boardRowsAmount);\r\n        \r\n        // Calculate the final board pixel size.\r\n        // This ensures that the board and tiles are always evenly sized and the board remains a square.\r\n        const newBoardSize = newTileSize * boardRowsAmount;\r\n\r\n        const boardDimensions: BoardDimensions = {\r\n            boardSize: newBoardSize,\r\n            tileSize: newTileSize\r\n        };\r\n        return boardDimensions;\r\n    }, [boardRowsAmount]);\r\n\r\n    /**\r\n     * Resizes the storage state of the board and tile size based on the current window size.\r\n     * @returns {void}\r\n     */\r\n    const resizeHandler = useCallback((): void => {\r\n        const {\r\n            boardSize: newBoardSize,\r\n            tileSize: newTileSize\r\n        } = calculateBoardSizes();\r\n\r\n        // If the recalculated tile size is the same as the current state,\r\n        // we don't need to update the state.\r\n        // We only check the tile size since if that changes, the board size also changes since the board size is dependent on the tile size.\r\n        //! Do note that we check the tile size instead of the board size since the board size stays the same if the rows amount changes, while the tile size changes accordingly (since we do availableSize / rowsAmount).\r\n        if (newTileSize === tileSize) {\r\n            return;\r\n        }\r\n        \r\n        setBoardSize(newBoardSize);\r\n        setTileSize(newTileSize);\r\n    }, [tileSize, setBoardSize, setTileSize, calculateBoardSizes]);\r\n\r\n    // - When the component mounts, it adds a resize event listener to the window.\r\n    // - When the component unmounts, it removes the resize event listener.\r\n    useEffect(() => {\r\n        window.addEventListener('resize', resizeHandler);\r\n        return () => {\r\n            window.removeEventListener('resize', resizeHandler);\r\n        };\r\n    }, [resizeHandler]);\r\n\r\n    // Calculate and set the initial board size and tile size when the component mounts.\r\n    useEffect(() => {\r\n        resizeHandler();\r\n    }, [resizeHandler]);\r\n\r\n    // Gets the size of the backgroundSize on the board. \r\n    // We do this here so that we don't have to calculate it twice within the style object.\r\n    const boardSquareSize = tileSize * 2;\r\n\r\n    return (\r\n        <div\r\n            className='position-absolute m-auto top-0 bottom-0 start-0 end-0 border border-dark'\r\n            data-testid='board'\r\n            style={{\r\n                width: `${boardSize}px`,\r\n                height: `${boardSize}px`,\r\n                background: 'linear-gradient(to bottom, black 50%, white 50%), linear-gradient(to right, white 50%, black 50%)',\r\n                backgroundBlendMode: 'difference, normal',\r\n                backgroundSize: `${boardSquareSize}px ${boardSquareSize}px`\r\n            }}\r\n        >\r\n            <Stones />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Board;","import { FC, lazy, Suspense, useEffect } from 'react';\r\nimport { useGameStorageContext } from './gameStorage/gameStorage.tsx';\r\nimport { ComponentName } from '../Window.tsx';\r\nimport { MovesStorageProvider } from './movesStorage/movesStorage.tsx';\r\nimport LoadingFallback from '../LoadingFallback.tsx';\r\nimport Board from './Board.tsx';\r\nconst GameOverOverlay = lazy(() => import('./GameOverOverlay.tsx'));\r\n\r\n/**\r\n * Props for the Game component.\r\n * - `toggleComponent`: Function to toggle the current component.\r\n */\r\ninterface GameProps {\r\n    toggleComponent: (componentName: ComponentName) => void;\r\n}\r\n\r\nconst Game: FC<GameProps> = (props) => {\r\n    const {\r\n        toggleComponent\r\n    } = props;\r\n\r\n    const { \r\n        isGameOver, \r\n        winner,\r\n        setIsGamePaused,\r\n        setIsGameRunning\r\n    } = useGameStorageContext();\r\n\r\n    /**\r\n     * Checks if the game over overlay should be displayed.\r\n     * @returns {boolean} - True if the game is over and there is a winner, false otherwise.\r\n     */\r\n    function shouldDisplayGameOverOverlay(): boolean {\r\n        const shouldDisplayGameOverOverlay = (\r\n            isGameOver &&\r\n            winner !== null\r\n        );\r\n        return shouldDisplayGameOverOverlay;\r\n    }\r\n\r\n    \r\n    // - When the component mounts, it adds a keydown event listener to the window.\r\n    // - When the component unmounts, it removes the keydown event listener.\r\n    useEffect(() => {\r\n        /**\r\n         * Handles the keydown event.\r\n         * - If the Escape key is pressed, it toggles the escape menu component.\r\n         * @param {KeyboardEvent} ev - The keyboard event.\r\n         * @returns {void}\r\n         */\r\n        const keydownHandler = (ev: KeyboardEvent): void => {\r\n            const pressedKey = ev.key;\r\n            if (pressedKey === 'Escape') {\r\n                setIsGamePaused(true);\r\n                toggleComponent('escapeMenu');\r\n            }\r\n        }\r\n\r\n        window.addEventListener('keydown', keydownHandler);\r\n        return () => {\r\n            window.removeEventListener('keydown', keydownHandler);\r\n        };\r\n    }, [toggleComponent, setIsGamePaused]);\r\n\r\n    // When the Game component mounts, we set the necessary game storage state flags to indicate that the game is running and not paused.\r\n    useEffect(() => {\r\n        setIsGamePaused(false);\r\n        setIsGameRunning(true);\r\n    }, [setIsGamePaused, setIsGameRunning]);\r\n\r\n    return (\r\n        <>\r\n            {shouldDisplayGameOverOverlay() && \r\n                <Suspense \r\n                    fallback={<LoadingFallback />}\r\n                >\r\n                    <GameOverOverlay\r\n                        toggleComponent={toggleComponent}\r\n                    />\r\n                </Suspense>\r\n            }\r\n            <Board />\r\n        </>\r\n    );\r\n}\r\n\r\nconst GameWithMovesProvider = (props: GameProps) => {\r\n    return (\r\n        <MovesStorageProvider>\r\n            <Game \r\n                {...props}\r\n            />\r\n            \r\n        </MovesStorageProvider>\r\n    );\r\n}\r\n\r\nexport default GameWithMovesProvider;"],"names":["MovesStorageContext","createContext","MovesStorageProvider","_ref","children","value","useMovesStorage","currentPlayer","boardGrid","useGameStorageContext","selectedPosition","setSelectedPosition","useState","currentPlayerMoveTrees","setCurrentPlayerMoveTrees","calculateCurrentPlayerMoveTrees","_jsx","Provider","_KING_ICON_DIMENSIONS_CACHE","_KING_ICON_CACHE","KingIcon","stoneDiameter","createKingIcon","cachedKingIcon","kingIcon","getKingIcon","width","height","left","top","calculateDimensions","cachedDimensions","iconSize","Math","round","iconCenterOffset","iconDimensions","FontAwesomeIcon","icon","faCrown","className","style","color","props","position","player","isKing","tileSize","context","useContext","Error","useMovesStorageProvider","stoneDimensions","useMemo","row","col","centeringOffset","diameter","canMove","positionString","toString","isSelected","backgroundColor","draggable","onMouseDown","ev","preventDefault","onDragOver","Stones","setStoneDiameter","useEffect","_Fragment","flatMap","map","stone","id","Stone","Board","setTileSize","boardSize","setBoardSize","boardRowsAmount","useSettingsStorageContext","calculateBoardSizes","useCallback","availableHeight","window","innerHeight","availableWidth","innerWidth","availableSize","min","newTileSize","floor","resizeHandler","newBoardSize","addEventListener","removeEventListener","boardSquareSize","background","backgroundBlendMode","backgroundSize","GameOverOverlay","lazy","Game","toggleComponent","isGameOver","winner","setIsGamePaused","setIsGameRunning","keydownHandler","key","_jsxs","Suspense","fallback","LoadingFallback"],"sourceRoot":""}